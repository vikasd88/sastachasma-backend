package com.sastachasma.order.service.impl;

import com.sastachasma.order.dto.OrderDTO;
import com.sastachasma.order.dto.request.PlaceOrderRequest;
import com.sastachasma.order.entity.*;
import com.sastachasma.order.exception.ResourceNotFoundException;
import com.sastachasma.order.lensclient.LensServiceClient;
import com.sastachasma.order.mapper.OrderMapper;
import com.sastachasma.order.repository.*;
import com.sastachasma.order.productclient.ProductServiceClient;
import com.sastachasma.order.service.OrderService;
import com.sastachasma.order.payment.PaymentService;
import org.springframework.transaction.annotation.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderMapper orderMapper;
    private final PaymentService paymentService;
    private final ProductServiceClient productServiceClient;
    private final LensServiceClient lensServiceClient;

    @Override
    @Transactional
    public OrderDTO placeOrder(String userId, PlaceOrderRequest request) {
        // Create order
        Order order = new Order();
        // Order number will be auto-generated by @PrePersist
        order.setUserId(userId);
        order.setCustomerName(request.getCustomerName());
        order.setStatus(Order.OrderStatus.PROCESSING);
        order.setOrderDate(LocalDateTime.now()); // Changed from ZonedDateTime
        order.setEstimatedDelivery(LocalDateTime.now().plusDays(7)); // Changed from ZonedDateTime

        // Set addresses. billingAddress will be used as the primary address.
        order.setBillingAddress(convertAddressToJson(request.getBillingAddress()));
        order.setShippingAddress(convertAddressToJson(request.getBillingAddress())); // Use billing as shipping if not separate

        // Set payment info
        order.setPaymentMethod(request.getPaymentMethod());
        order.setPaymentStatus("PENDING"); // Initial payment status
        // PaymentTransactionId will be set after successful payment processing

        BigDecimal subtotal = BigDecimal.ZERO;
        BigDecimal lensTotal = BigDecimal.ZERO;

        // Create order items
        for (PlaceOrderRequest.OrderItemRequest itemRequest : request.getItems()) {
            // Deduct product stock
            productServiceClient.updateProductStock(itemRequest.getProductId(), -itemRequest.getQuantity());
            // Deduct lens stock if applicable
            if (itemRequest.getLensId() != null) {
                lensServiceClient.updateLensStock(itemRequest.getLensId(), -itemRequest.getQuantity());
            }

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(order);
            orderItem.setProductId(itemRequest.getProductId());
            orderItem.setName(itemRequest.getName());
            
            // Set both price and unitPrice to ensure consistency
            BigDecimal unitPrice = itemRequest.getUnitPrice() != null ? 
                itemRequest.getUnitPrice() : BigDecimal.ZERO;
                
            orderItem.setUnitPrice(unitPrice);
            orderItem.setPrice(unitPrice); // Set price explicitly
            
            orderItem.setQuantity(itemRequest.getQuantity() != null ? 
                itemRequest.getQuantity() : 1);
                
            orderItem.setImageUrl(itemRequest.getImageUrl());
            orderItem.setLensId(itemRequest.getLensId());
            orderItem.setLensType(itemRequest.getLensType());
            orderItem.setLensMaterial(itemRequest.getLensMaterial());
            orderItem.setLensPrescriptionRange(itemRequest.getLensPrescriptionRange());
            orderItem.setLensCoating(itemRequest.getLensCoating());
            orderItem.setLensPrice(itemRequest.getLensPrice());
            // frameSize is not part of OrderItem entity, removed.

            BigDecimal itemTotal = orderItem.getUnitPrice().multiply(BigDecimal.valueOf(orderItem.getQuantity()));
            if (orderItem.getLensPrice() != null) {
                itemTotal = itemTotal.add(orderItem.getLensPrice().multiply(BigDecimal.valueOf(orderItem.getQuantity())));
                lensTotal = lensTotal.add(orderItem.getLensPrice().multiply(BigDecimal.valueOf(orderItem.getQuantity())));
            }
            orderItem.setTotalPrice(itemTotal);
            subtotal = subtotal.add(itemTotal);

            order.getItems().add(orderItem);
        }

        order.setSubtotal(subtotal);
        order.setShippingFee(BigDecimal.ZERO); // Default or calculate based on logic
        order.setTax(BigDecimal.ZERO); // Default or calculate based on logic
        order.setTotalAmount(subtotal.add(order.getShippingFee()).add(order.getTax()));

        // Add default status history
        OrderStatusHistory history = new OrderStatusHistory();
        history.setOrder(order);
        history.setStatus("PROCESSING");
        history.setStatusDate(LocalDateTime.now()); // Changed from ZonedDateTime
        history.setDescription("Order received and is being processed.");
        order.getStatusHistory().add(history);

        // Process payment
        boolean paymentSuccessful = paymentService.processPayment(
                request.getPaymentMethod(),
                order.getTotalAmount(), // Use calculated total amount
                null // Transaction ID will be generated by payment service
        );

        if (!paymentSuccessful) {
            throw new IllegalStateException("Payment failed for order.");
        }

        // Save order
        Order savedOrder = orderRepository.save(order);
        return orderMapper.toDto(savedOrder);
    }

    private String convertAddressToJson(PlaceOrderRequest.BillingAddress address) {
        // Existing address conversion logic
        return String.format(
            "{\"street\":\"%s\",\"city\":\"%s\",\"state\":\"%s\",\"postalCode\":\"%s\",\"country\":\"%s\",\"phone\":\"%s\"}",
            address.getStreet() != null ? address.getStreet().replace("\"", "\\\"") : "",
            address.getCity() != null ? address.getCity().replace("\"", "\\\"") : "",
            address.getState() != null ? address.getState().replace("\"", "\\\"") : "",
            address.getPostalCode() != null ? address.getPostalCode().replace("\"", "\\\"") : "",
            address.getCountry() != null ? address.getCountry().replace("\"", "\\\"") : "",
            address.getPhone() != null ? address.getPhone().replace("\"", "\\\"") : ""
        );
    }

    @Override
    public List<OrderDTO> getAllOrders() {
        return orderRepository.findAll().stream()
                .map(orderMapper::toDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public OrderDTO getOrderById(Long id) {
        Order order = orderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with id: " + id));
        return orderMapper.toDto(order);
    }

    @Override
    @Transactional(readOnly = true)
    public OrderDTO getOrder(String userId, String orderNumber) {
        Order order = orderRepository.findByOrderNumber(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with number: " + orderNumber));

        if (!order.getUserId().equals(userId)) {
            throw new SecurityException("You are not authorized to view this order");
        }

        return orderMapper.toDto(order);
    }

    @Override
    @Transactional(readOnly = true)
    public List<OrderDTO> getUserOrders(String userId) {
        return orderRepository.findByUserIdOrderByCreatedAtDesc(userId).stream()
                .map(orderMapper::toDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public OrderDTO updateOrderStatus(String orderNumber, String status) {
        Order order = orderRepository.findByOrderNumber(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with number: " + orderNumber));

        try {
            Order.OrderStatus newStatus = Order.OrderStatus.valueOf(status.toUpperCase());
            order.setStatus(newStatus);
            order.setUpdatedAt(LocalDateTime.now()); // Changed from ZonedDateTime
            return orderMapper.toDto(orderRepository.save(order));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid order status: " + status);
        }
    }

    @Override
    @Transactional
    public void cancelOrder(String userId, String orderNumber) {
        Order order = orderRepository.findByOrderNumber(orderNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Order not found with number: " + orderNumber));

        if (!order.getUserId().equals(userId)) {
            throw new SecurityException("You are not authorized to cancel this order");
        }

        if (order.getStatus() == Order.OrderStatus.CANCELLED) {
            throw new IllegalStateException("Order is already cancelled");
        }

        if (order.getStatus() == Order.OrderStatus.DELIVERED) {
            throw new IllegalStateException("Cannot cancel an already delivered order");
        }

        // Return items to stock using ProductServiceClient
        for (OrderItem item : order.getItems()) {
            productServiceClient.updateProductStock(item.getProductId(), item.getQuantity());
            // Return lens stock if applicable
            if (item.getLensId() != null) {
                lensServiceClient.updateLensStock(item.getLensId(), item.getQuantity());
            }
        }

        order.setStatus(Order.OrderStatus.CANCELLED);
        order.setUpdatedAt(LocalDateTime.now()); // Changed from ZonedDateTime
        orderRepository.save(order);
    }
}
